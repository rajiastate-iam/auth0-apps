
name: Apply Auth0 Changes

on:
  push:
    branches: ["main", "master"]
    paths:
      - "apps/**/*.yaml"
      - "apps/**/*.yml"
      - "*.tf"
      - "**/*.tf"

permissions:
  contents: read

concurrency:
  group: terraform-apply
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    env:
      AUTH0_DOMAIN:        ${{ secrets.AUTH0_DOMAIN }}
      AUTH0_CLIENT_ID:     ${{ secrets.AUTH0_CLIENT_ID }}
      AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
      TF_VAR_auth0_domain:        ${{ secrets.AUTH0_DOMAIN }}
      TF_VAR_auth0_client_id:     ${{ secrets.AUTH0_CLIENT_ID }}
      TF_VAR_auth0_client_secret: ${{ secrets.AUTH0_CLIENT_SECRET }}

      # >>>> FILL WITH THE SAME STATIC IDs AS locals.tf <<<<
      # These are NOT secrets; IDs are fine to log. Keeping here keeps GH workflow self-contained.
      ALLOWED_CONNECTION_IDS: "con_aaaaaaaaaaaaaaaa,con_bbbbbbbbbbbbbbbb"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed app files
        id: pick
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $before = "${{ github.event.before }}"
          $after  = "${{ github.sha }}"
          if ([string]::IsNullOrWhiteSpace($before) -or $before -eq "0000000000000000000000000000000000000000") {
            $before = $(git rev-parse HEAD~1)
          }
          $changed = @(git diff --name-only $before $after |
            Where-Object { $_ -match '^apps\/.*\.ya?ml$' } |
            ForEach-Object { $_.Trim() } |
            Sort-Object -Unique)

          if ($changed.Count -eq 0) {
            Write-Host "No app YAML changes detected; nothing to apply."
            "changed_json=[]" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          } else {
            $json = "[" + (($changed | ForEach-Object { '"' + ($_ -replace '"','\"') + '"' }) -join ",") + "]"
            "changed_json=$json" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            Write-Host "Changed files:"; $changed | ForEach-Object { Write-Host " - $_" }
          }

      - uses: hashicorp/setup-terraform@v3

      - name: Build apps.auto.tfvars.json (PowerShell)
        shell: pwsh
        env:
          CHANGED_JSON: ${{ steps.pick.outputs.changed_json }}
        run: |
          $ErrorActionPreference = "Stop"
          try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
          Install-Module powershell-yaml -Scope CurrentUser -Force
          Import-Module powershell-yaml

          $paths = ConvertFrom-Json -InputObject $env:CHANGED_JSON
          if ($paths -isnot [System.Collections.IEnumerable]) { $paths = @($paths) }

          $apps  = @()
          foreach ($p in $paths) {
            $apps += (Get-Content $p -Raw | ConvertFrom-Yaml)
          }
          $tfvars = @{ apps = $apps }
          $json   = $tfvars | ConvertTo-Json -Depth 50
          Set-Content -Path "apps.auto.tfvars.json" -Value $json -Encoding UTF8
          Write-Host "Wrote apps.auto.tfvars.json with $($apps.Count) app(s)."

      - name: Terraform Init
        run: terraform init -input=false

      - name: Terraform Plan
        id: tfplan
        run: terraform plan -input=false -no-color -out=tfplan

      - name: Show Plan
        run: terraform show -no-color tfplan

      - name: Terraform Apply
        run: terraform apply -input=false -auto-approve tfplan

      # ---------- POST-APPLY ASSERT + CORRECT ----------
      - name: Ensure only allowed connections are enabled for each client
        shell: pwsh
        env:
          CHANGED_JSON: ${{ steps.pick.outputs.changed_json }}
        run: |
          $ErrorActionPreference = "Stop"

          $paths = ConvertFrom-Json -InputObject $env:CHANGED_JSON
          if ($paths -isnot [System.Collections.IEnumerable]) { $paths = @($paths) }

          # Build allowed list from env (static IDs)
          $allowed = @()
          if (-not [string]::IsNullOrWhiteSpace($env:ALLOWED_CONNECTION_IDS)) {
            $allowed = $env:ALLOWED_CONNECTION_IDS.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
          }

          $aud = "https://$env:AUTH0_DOMAIN/api/v2/"
          $body = @{
            client_id     = $env:AUTH0_CLIENT_ID
            client_secret = $env:AUTH0_CLIENT_SECRET
            audience      = $aud
            grant_type    = "client_credentials"
          } | ConvertTo-Json
          $tokResp = Invoke-RestMethod -Method Post -Uri "https://$($env:AUTH0_DOMAIN)/oauth/token" `
            -ContentType "application/json" -Body $body
          $token = $tokResp.access_token
          if (-not $token) { throw "Failed to get Auth0 token for assertion." }

          try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
          Install-Module powershell-yaml -Scope CurrentUser -Force
          Import-Module powershell-yaml

          foreach ($path in $paths) {
            $obj      = (Get-Content $path -Raw) | ConvertFrom-Yaml
            $display  = [string]$obj.displayname

            # Resolve client_id by display name
            $clients  = Invoke-RestMethod -Method Get -Uri "https://$($env:AUTH0_DOMAIN)/api/v2/clients?per_page=100" `
                          -Headers @{ Authorization = "Bearer $token" }
            $clientId = ($clients | Where-Object { $_.name -eq $display }).client_id
            if (-not $clientId) { throw "Client '$display' not found after apply." }

            # Fetch all connections and ensure only allowed set has this client enabled
            $connList = Invoke-RestMethod -Method Get -Uri "https://$($env:AUTH0_DOMAIN)/api/v2/connections?per_page=100&page=0" `
                          -Headers @{ Authorization = "Bearer $token" }

            $bad = $false
            foreach ($conn in $connList) {
              $cid = $conn.id
              $enabled = @($conn.enabled_clients)
              $has     = ($enabled -contains $clientId)
              $should  = ($allowed -contains $cid)

              if ($should -and (-not $has)) {
                # Add this client to allowed connections if missing
                $new = @($enabled + $clientId | Sort-Object -Unique)
                Invoke-RestMethod -Method Patch `
                  -Uri "https://$($env:AUTH0_DOMAIN)/api/v2/connections/$cid" `
                  -Headers @{ Authorization = "Bearer $token" } `
                  -ContentType "application/json" `
                  -Body ( @{ enabled_clients = $new } | ConvertTo-Json )
              }
              elseif ((-not $should) -and $has) {
                # Remove from non-allowed connections
                $new = @($enabled | Where-Object { $_ -ne $clientId })
                Invoke-RestMethod -Method Patch `
                  -Uri "https://$($env:AUTH0_DOMAIN)/api/v2/connections/$cid" `
                  -Headers @{ Authorization = "Bearer $token" } `
                  -ContentType "application/json" `
                  -Body ( @{ enabled_clients = $new } | ConvertTo-Json )
                $bad = $true
              }
            }

            if ($bad) {
              Write-Host "Adjusted connections for '$display' to only allowed set."
            } else {
              Write-Host "Post-apply assertion passed for '$display' âœ…"
            }
          }

      # ---------- FAILURE CLEANUP ----------
      - name: Cleanup client on failure (soft rollback)
        if: ${{ failure() }}
        shell: pwsh
        env:
          CHANGED_JSON: ${{ steps.pick.outputs.changed_json }}
        run: |
          $ErrorActionPreference = "Stop"

          $paths = ConvertFrom-Json -InputObject $env:CHANGED_JSON
          if ($paths -isnot [System.Collections.IEnumerable]) { $paths = @($paths) }
          if (-not $paths -or $paths.Count -eq 0) { Write-Host "No files; skip cleanup."; exit 0 }

          $aud = "https://$env:AUTH0_DOMAIN/api/v2/"
          $body = @{
            client_id     = $env:AUTH0_CLIENT_ID
            client_secret = $env:AUTH0_CLIENT_SECRET
            audience      = $aud
            grant_type    = "client_credentials"
          } | ConvertTo-Json
          $tokResp = Invoke-RestMethod -Method Post -Uri "https://$($env:AUTH0_DOMAIN)/oauth/token" `
            -ContentType "application/json" -Body $body
          $token = $tokResp.access_token
          if (-not $token) { Write-Host "No token; skipping cleanup."; exit 0 }

          try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
          Install-Module powershell-yaml -Scope CurrentUser -Force
          Import-Module powershell-yaml

          foreach ($path in $paths) {
            $obj     = (Get-Content $path -Raw) | ConvertFrom-Yaml
            $display = [string]$obj.displayname
            $clients = Invoke-RestMethod -Method Get -Uri "https://$($env:AUTH0_DOMAIN)/api/v2/clients?per_page=100" `
                        -Headers @{ Authorization = "Bearer $token" }
            $clientId = ($clients | Where-Object { $_.name -eq $display }).client_id
            if ($clientId) {
              Write-Host "Deleting client '$display' ($clientId) due to failure."
              Invoke-RestMethod -Method Delete -Uri "https://$($env:AUTH0_DOMAIN)/api/v2/clients/$clientId" `
                -Headers @{ Authorization = "Bearer $token" } -ErrorAction SilentlyContinue
            }
          }
